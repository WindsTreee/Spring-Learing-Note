<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-649d3c80-8a4e-4758-84a8-63448bf7f3f1"></attachment><p>线程的join作用是调用线程等待该线程完成后才能继续运行。</p><pre class="ql-syntax" spellcheck="false">public static void main(String[] args) throws InterruptedException
    {
        System.out.println("main start");

        Thread t1 = new Thread(new Worker("thread-1"));
        t1.start();
        t1.join();
        System.out.println("main end");
    }
</pre><p>在这个例子中，如果不加join，t1和main线程是并行执行的，加了join之后，main会等t1执行完了之后再输出main end</p><p>wait：让线程处于等待状态</p><p>notify：唤醒处于wait状态的线程</p><p>notifyAll：唤醒处于wait状态的所有线程</p><p>wait，notify，notifyAll一般都是在synchronized代码块中使用。</p><p>synchronized,while,wait,notfiy结合可以实现经典的生产者消费者模式</p><p><strong>notify和notifyAll的区别</strong></p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们首先得明确,一个对象只有一个锁,参与该对象锁竞争的线程,与参与其他对象锁竞争的线程无关.线程竞争,对应一个对象的一个锁.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有n个线程参与竞争同一对象的锁,t1率先抢到了锁,锁池中有n-1个线程在等待竞争锁,t1调用了wait()方法t1线程挂起,等待池中有一线程等待被唤醒.t2线程,获得了锁,锁池中有n-2个线程等待竞争锁,t2线程调用了wait方法挂起,等待池中有两个线程等待被唤醒,</p><p>此时t3线程获得了锁,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果t3线程在同步代码块中调用的是notify则只会随机唤醒等待池中的一个线程移入锁池中参与锁竞争,有可能是t1,也有可能是t2,等待池中的线程为1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果t3线程在同步代码块中调用的notifyAll,则会同时唤醒t1,t2移入锁池中参与竞争,等待池中的线程为零,</p><p><br></p>