<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-649d3c80-8a4e-4758-84a8-63448bf7f3f1"></attachment><p>线程的join作用是调用线程等待该线程完成后才能继续运行。</p><p><br></p><pre class="ql-syntax" spellcheck="false">public static void main(String[] args) throws InterruptedException
    {
        System.out.println("main start");

        Thread t1 = new Thread(new Worker("thread-1"));
        t1.start();
        t1.join();
        System.out.println("main end");
    }
</pre><p>在这个例子中，如果不加join，t1和main线程是并行执行的，加了join之后，main会等t1执行完了之后再输出main end</p><p>wait：让线程处于等待状态</p><p>notify：唤醒处于wait状态的线程</p><p>notifyAll：唤醒处于wait状态的所有线程</p><p>wait，notify，notifyAll一般都是在synchronized代码块中使用。</p><p>synchronized,while,wait,notfiy结合可以实现经典的生产者消费者模式</p><p><br></p><p><strong>notify和notifyAll的区别</strong></p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们首先得明确,一个对象只有一个锁,参与该对象锁竞争的线程,与参与其他对象锁竞争的线程无关.线程竞争,对应一个对象的一个锁.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有n个线程参与竞争同一对象的锁,t1率先抢到了锁,锁池中有n-1个线程在等待竞争锁,t1调用了wait()方法t1线程挂起,等待池中有一线程等待被唤醒.t2线程,获得了锁,锁池中有n-2个线程等待竞争锁,t2线程调用了wait方法挂起,等待池中有两个线程等待被唤醒,</p><p>此时t3线程获得了锁,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果t3线程在同步代码块中调用的是notify则只会随机唤醒等待池中的一个线程移入锁池中参与锁竞争,有可能是t1,也有可能是t2,等待池中的线程为1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果t3线程在同步代码块中调用的notifyAll,则会同时唤醒t1,t2移入锁池中参与竞争,等待池中的线程为零,</p><p><br></p><p>JDK1.8之后hashmap的resize不会造成死锁问题，但是它仍然是线程不安全的，因为它在进行put操作的时候可能导致多线程数据不一致</p><p><br></p><p>mybatis中#{}在进行预编译时会被替换为?，然后再被放入值，而${}则是在预编译时直接被替换为对应值，有sql注入的风险</p><p><br></p><p>ArrayList默认容量为10，扩容时扩容为原来大小的1.5倍</p><p><br></p><p>浅拷贝：<span style="background-color: rgb(254, 254, 242);">①对于数据类型是</span><span style="background-color: rgb(0, 255, 0);">基本数据类型</span><span style="background-color: rgb(254, 254, 242);">的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，</span><span style="background-color: rgb(0, 255, 0);">不会影响另一个对象拷贝得到的数据</span><span style="background-color: rgb(254, 254, 242);">。②对于数据类型是</span><span style="background-color: rgb(0, 255, 0);">引用数据类型的成员变量</span><span style="background-color: rgb(254, 254, 242);">，比如说成员</span><span style="background-color: rgb(0, 255, 0);">变量是某个数组、某个类的对象</span><span style="background-color: rgb(254, 254, 242);">等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上</span><span style="background-color: rgb(0, 255, 0);">两个对象的该成员变量都指向同一个实例</span><span style="background-color: rgb(254, 254, 242);">。在这种情况下，在一个对象中修改该成员变量会</span><span style="background-color: rgb(0, 255, 0);">影响</span><span style="background-color: rgb(254, 254, 242);">到另一个对象的该成员变量值。</span></p><p><span style="background-color: rgb(254, 254, 242);">深拷贝：为每个拷贝的对象都重新开辟空间</span></p><p><br></p>